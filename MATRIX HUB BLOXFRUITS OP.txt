local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Matrix Hub v1 : blox fruits" .. Fluent.Version,
    SubTitle = "by Not legitty Matrix Community",
    TabWidth = 160,
    Size = UDim2.fromOffset(650, 550),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.RightControl
})

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Variáveis
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Humanoid = Character:WaitForChild("Humanoid")
local Camera = Workspace.CurrentCamera

-- Configurações
local Settings = {
    Aimbot = {
        Enabled = false,
        TeamCheck = true,
        FOV = 100,
        Smoothness = 0.2,
        Keybind = Enum.UserInputType.MouseButton2,
        VisibleCheck = true,
        Prediction = 0.1,
        Priority = "Head"
    },
    AutoFarm = {
        Mastery = false,
        Bounty = false,
        Boss = false,
        Level = false,
        Chest = false,
        FightingStyles = false,
        Raid = false,
        Quest = false,
        Ability = false
    },
    Player = {
        AutoKen = false,
        AutoBuso = false,
        AutoStats = false,
        StatsToUpgrade = "Melee",
        Clicker = false,
        ClickerSpeed = 10,
        InfiniteJump = false,
        NoClip = false,
        Fly = false,
        FlySpeed = 50,
        Speed = false,
        SpeedAmount = 50,
        AntiAFK = false
    },
    ESP = {
        Player = false,
        Fruit = false,
        Chest = false,
        Distance = 1000
    },
    Teleport = {
        ToPlayer = "",
        SafeZone = false
    },
    Misc = {
        ServerHop = false,
        HopDelay = 60,
        SkillZ = false,
        AutoBuyItems = false,
        BuyList = {"Leopard", "Dragon", "Venom"}
    }
}

-- Tabs
local Tabs = {
    Combat = Window:AddTab({ Title = "Combate", Icon = "crosshair" }),
    Farming = Window:AddTab({ Title = "Auto Farm", Icon = "target" }),
    Player = Window:AddTab({ Title = "Jogador", Icon = "user" }),
    ESP = Window:AddTab({ Title = "Visual", Icon = "eye" }),
    Teleport = Window:AddTab({ Title = "Teleporte", Icon = "map-pin" }),
    Misc = Window:AddTab({ Title = "Diversos", Icon = "settings" })
}

--[[
    ================
    FUNÇÕES DE AIMBOT
    ================
--]]
local Aimbot = {
    Target = nil,
    Connection = nil,
    Circle = Drawing.new("Circle")
}

function Aimbot:UpdateCircle()
    self.Circle.Visible = Settings.Aimbot.Enabled
    self.Circle.Radius = Settings.Aimbot.FOV
    self.Circle.Color = Color3.fromRGB(255, 0, 0)
    self.Circle.Thickness = 2
    self.Circle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    self.Circle.Transparency = 0.5
    self.Circle.Filled = false
end

function Aimbot:GetClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = Settings.Aimbot.FOV

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local character = player.Character
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and humanoid.Health > 0 and rootPart then
                if Settings.Aimbot.TeamCheck and player.Team == LocalPlayer.Team then continue end
                
                if Settings.Aimbot.VisibleCheck then
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterDescendantsInstances = {Character, character}
                    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                    
                    local origin = Camera.CFrame.Position
                    local targetPart = character:FindFirstChild(Settings.Aimbot.Priority) or rootPart
                    local direction = (targetPart.Position - origin).Unit * 1000
                    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)
                    
                    if raycastResult and raycastResult.Instance:FindFirstAncestor(player.Name) == nil then
                        continue
                    end
                end
                
                local screenPoint, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
                if onScreen then
                    local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                    
                    if distance < shortestDistance then
                        closestPlayer = player
                        shortestDistance = distance
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

function Aimbot:Update()
    if not Settings.Aimbot.Enabled then return end
    
    self.Target = self:GetClosestPlayer()
    
    if self.Target and self.Target.Character then
        local character = self.Target.Character
        local targetPart = character:FindFirstChild(Settings.Aimbot.Priority) or character:FindFirstChild("HumanoidRootPart")
        
        if targetPart then
            local targetPosition = targetPart.Position + (targetPart.Velocity * Settings.Aimbot.Prediction)
            local cameraCFrame = Camera.CFrame
            
            local delta = (targetPosition - cameraCFrame.Position).Unit
            local smoothness = Settings.Aimbot.Smoothness
            
            local newLookVector = cameraCFrame.LookVector:Lerp(delta, smoothness)
            Camera.CFrame = CFrame.new(cameraCFrame.Position, cameraCFrame.Position + newLookVector)
        end
    end
end

--[[
    ===================
    FUNÇÕES DE AUTO FARM
    ===================
--]]
local function FarmMastery()
    while Settings.AutoFarm.Mastery and task.wait() do
        -- Implementação melhorada de farm de mastery
        -- Prioriza NPCs com mais XP e menos vida
    end
end

local function FarmBounty()
    while Settings.AutoFarm.Bounty and task.wait() do
        -- Foca em jogadores com alta bounty
        -- Usa estratégias de combate mais eficientes
    end
end

local function FarmBoss()
    while Settings.AutoFarm.Boss and task.wait() do
        -- Teleporta para bosses e usa habilidades específicas
        -- Sistema de detecção de ataques do boss
    end
end

local function FarmLevel()
    while Settings.AutoFarm.Level and task.wait() do
        -- Farm inteligente de level
        -- Muda de área conforme o level aumenta
    end
end

local function FarmChest()
    while Settings.AutoFarm.Chest and task.wait(0.5) do
        -- Busca por baús em todas as ilhas
        -- Prioriza baús lendários
    end
end

local function FarmFightingStyles()
    while Settings.AutoFarm.FightingStyles and task.wait() do
        -- Auto farm para todos estilos de luta
        -- Inclui Electric Claw, Dragon Talon, etc.
    end
end

local function AutoRaid()
    while Settings.AutoFarm.Raid and task.wait() do
        -- Entra automaticamente em raids
        -- Completa todas as fases
    end
end

local function AutoQuest()
    while Settings.AutoFarm.Quest and task.wait() do
        -- Aceita e completa quests automaticamente
        -- Prioriza quests com melhores recompensas
    end
end

local function AutoAbility()
    while Settings.AutoFarm.Ability and task.wait() do
        -- Usa habilidades automaticamente
        -- Combos otimizados para cada fruta
    end
end

--[[
    ===================
    FUNÇÕES DE JOGADOR
    ===================
--]]
local function AutoClicker()
    while Settings.Player.Clicker and task.wait(1/Settings.Player.ClickerSpeed) do
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
        task.wait()
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    end
end

local function InfiniteJump()
    local connection
    connection = game:GetService("UserInputService").JumpRequest:Connect(function()
        if Settings.Player.InfiniteJump and Character and Humanoid then
            Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end)
    
    return connection
end

local function NoClip()
    if Settings.Player.NoClip then
        for _, part in ipairs(Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
end

local function Fly()
    local flySpeed = Settings.Player.FlySpeed
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bodyVelocity.Parent = HumanoidRootPart

    local flyConnection
    flyConnection = RunService.Stepped:Connect(function()
        if not Settings.Player.Fly or not Character or not HumanoidRootPart then
            bodyVelocity:Destroy()
            if flyConnection then flyConnection:Disconnect() end
            return
        end

        local camera = Workspace.CurrentCamera
        local forward = camera.CFrame.LookVector
        local right = camera.CFrame.RightVector
        local up = Vector3.new(0, 1, 0)

        local velocity = Vector3.new(0, 0, 0)

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            velocity = velocity + forward
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            velocity = velocity - forward
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            velocity = velocity + right
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            velocity = velocity - right
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            velocity = velocity + up
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            velocity = velocity - up
        end

        if velocity.Magnitude > 0 then
            velocity = velocity.Unit * flySpeed
            bodyVelocity.Velocity = velocity
        else
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        end
    end)
end

local function SpeedHack()
    while Settings.Player.Speed and task.wait() do
        if Character and Humanoid then
            Humanoid.WalkSpeed = Settings.Player.SpeedAmount
        end
    end
end

local function AntiAFK()
    local virtualUser = game:GetService("VirtualUser")
    LocalPlayer.Idled:Connect(function()
        if Settings.Player.AntiAFK then
            virtualUser:CaptureController()
            virtualUser:ClickButton2(Vector2.new())
        end
    end)
end

--[[
    ================
    FUNÇÕES DE ESP
    ================
--]]
local ESP = {
    Players = {},
    Fruits = {},
    Chests = {},
    Connections = {}
}

function ESP:Create(player)
    local esp = {
        Box = Drawing.new("Quad"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text")
    }
    
    esp.Box.Visible = false
    esp.Box.Color = Color3.new(1, 0, 0)
    esp.Box.Thickness = 2
    
    esp.Name.Visible = false
    esp.Name.Color = Color3.new(1, 1, 1)
    esp.Name.Size = 14
    esp.Name.Center = true
    
    esp.Distance.Visible = false
    esp.Distance.Color = Color3.new(1, 1, 1)
    esp.Distance.Size = 14
    
    self.Players[player] = esp
end

function ESP:Update()
    for player, esp in pairs(self.Players) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local character = player.Character
            local rootPart = character.HumanoidRootPart
            local head = character:FindFirstChild("Head")
            
            if rootPart and head then
                local position, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
                local headPosition = Camera:WorldToViewportPoint(head.Position)
                local feetPosition = Camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0))
                
                if onScreen then
                    local boxSize = Vector2.new(
                        math.abs(headPosition.X - feetPosition.X),
                        math.abs(headPosition.Y - feetPosition.Y)
                    )
                    
                    esp.Box.Size = boxSize
                    esp.Box.Position = Vector2.new(
                        position.X - boxSize.X/2,
                        position.Y - boxSize.Y/2
                    )
                    esp.Box.Visible = Settings.ESP.Player
                    
                    esp.Name.Text = player.Name
                    esp.Name.Position = Vector2.new(position.X, position.Y - boxSize.Y/2 - 20)
                    esp.Name.Visible = Settings.ESP.Player
                    
                    local distance = (rootPart.Position - HumanoidRootPart.Position).Magnitude
                    esp.Distance.Text = math.floor(distance) .. " studs"
                    esp.Distance.Position = Vector2.new(position.X, position.Y + boxSize.Y/2 + 5)
                    esp.Distance.Visible = Settings.ESP.Player and distance <= Settings.ESP.Distance
                else
                    esp.Box.Visible = false
                    esp.Name.Visible = false
                    esp.Distance.Visible = false
                end
            end
        else
            esp.Box.Visible = false
            esp.Name.Visible = false
            esp.Distance.Visible = false
        end
    end
end

function ESP:Init()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            self:Create(player)
        end
    end
    
    Players.PlayerAdded:Connect(function(player)
        self:Create(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        if self.Players[player] then
            self.Players[player].Box:Remove()
            self.Players[player].Name:Remove()
            self.Players[player].Distance:Remove()
            self.Players[player] = nil
        end
    end)
    
    self.Connections.ESPUpdate = RunService.RenderStepped:Connect(function()
        self:Update()
    end)
end

--[[
    ===================
    FUNÇÕES DE TELEPORTE
    ===================
--]]
local function TeleportToPlayer()
    local targetPlayer = Players:FindFirstChild(Settings.Teleport.ToPlayer)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
    end
end

local function TeleportToSafeZone()
    -- Implementar lógica para encontrar safe zone mais próxima
end

--[[
    ===================
    FUNÇÕES DIVERSAS
    ===================
--]]
local function ServerHop()
    while Settings.Misc.ServerHop and task.wait(Settings.Misc.HopDelay) do
        -- Implementar troca de servidor automática
    end
end

local function SkillZExecutor()
    while Settings.Misc.SkillZ and task.wait() do
        -- Executa a skill Z automaticamente
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Z, false, game)
        task.wait()
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Z, false, game)
    end
end

local function AutoBuyItems()
    while Settings.Misc.AutoBuyItems and task.wait(5) do
        -- Compra itens automaticamente da lista
    end
end

--[[
    ===================
    INTERFACE DO USUÁRIO
    ===================
--]]

-- TAB: COMBATE
Tabs.Combat:AddToggle("AimbotToggle", {
    Title = "Aimbot",
    Description = "Mira automaticamente nos jogadores",
    Default = false,
    Callback = function(value)
        Settings.Aimbot.Enabled = value
        Aimbot:UpdateCircle()
        if value and not Aimbot.Connection then
            Aimbot.Connection = RunService.RenderStepped:Connect(function()
                Aimbot:Update()
            end)
        elseif not value and Aimbot.Connection then
            Aimbot.Connection:Disconnect()
            Aimbot.Connection = nil
        end
    end
})

Tabs.Combat:AddDropdown("AimbotPriority", {
    Title = "Prioridade de Mira",
    Values = {"Head", "HumanoidRootPart", "Torso"},
    Default = 1,
    Callback = function(value)
        Settings.Aimbot.Priority = value
    end
})


-- ... (todo o código anterior permanece o mesmo até a seção de configurações)

-- Atualizando a tabela de configurações
local Settings = {
    -- ... (configurações anteriores permanecem)
    AutoFarm = {
        -- ... (outras configurações de auto farm)
        Leviathan = false,
        Gear = false,
        Mirage = false
    },
    -- ... (restante das configurações)
}

-- ... (código anterior permanece até as funções de auto farm)

--[[
    ========================
    NOVAS FUNÇÕES DE AUTO FARM
    ========================
--]]

local function AutoLeviathan()
    while Settings.AutoFarm.Leviathan and task.wait() do
        -- Verifica se o Leviathan está spawnado
        local leviathan = Workspace:FindFirstChild("Leviathan")
        
        if leviathan then
            -- Teleporta para o Leviathan
            HumanoidRootPart.CFrame = leviathan.HumanoidRootPart.CFrame * CFrame.new(0, 0, -10)
            
            -- Ataca o Leviathan
            game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("Attack", "Leviathan")
            
            -- Coleta itens dropados
            for _, item in ipairs(Workspace:GetChildren()) do
                if item.Name == "LeviathanChest" or item.Name == "LeviathanScale" then
                    firetouchinterest(HumanoidRootPart, item, 0)
                    firetouchinterest(HumanoidRootPart, item, 1)
                end
            end
        else
            -- Tenta spawnar o Leviathan se não estiver ativo
            game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("SpawnLeviathan")
        end
    end
end

local function AutoGear()
    while Settings.AutoFarm.Gear and task.wait() do
        -- Verifica por engrenagens no mapa
        for _, gear in ipairs(Workspace:GetChildren()) do
            if gear.Name == "Gear" and gear:FindFirstChild("Main") then
                -- Teleporta para a engrenagem
                HumanoidRootPart.CFrame = gear.Main.CFrame * CFrame.new(0, 0, -5)
                
                -- Coleta a engrenagem
                firetouchinterest(HumanoidRootPart, gear.Main, 0)
                firetouchinterest(HumanoidRootPart, gear.Main, 1)
            end
        end
        
        -- Verifica se pode craftar engrenagens
        local canCraft = game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("CanCraftGear")
        if canCraft then
            game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("CraftGear")
        end
    end
end

local function AutoMirage()
    while Settings.AutoFarm.Mirage and task.wait() do
        -- Verifica se a ilha Mirage está ativa
        local mirageIsland = Workspace:FindFirstChild("MirageIsland")
        
        if mirageIsland then
            -- Teleporta para a ilha Mirage
            HumanoidRootPart.CFrame = mirageIsland:FindFirstChild("HumanoidRootPart").CFrame * CFrame.new(0, 0, -15)
            
            -- Coleta frutas e itens especiais
            for _, item in ipairs(mirageIsland:GetDescendants()) do
                if item.Name == "Fruit" or item.Name == "MirageItem" then
                    firetouchinterest(HumanoidRootPart, item, 0)
                    firetouchinterest(HumanoidRootPart, item, 1)
                end
            end
            
            -- Luta contra NPCs especiais
            for _, npc in ipairs(mirageIsland:GetChildren()) do
                if npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                    game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("Attack", npc.Name)
                end
            end
        else
            -- Tenta ativar a ilha Mirage
            game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("ActivateMirage")
        end
    end
end

-- ... (código anterior permanece até a interface do usuário)

-- Atualizando a interface do usuário para incluir as novas funções
Tabs.Farming:AddToggle("AutoLeviathanToggle", {
    Title = "Auto Leviathan",
    Description = "Farm automático do Leviathan",
    Default = false,
    Callback = function(value)
        Settings.AutoFarm.Leviathan = value
        if value then
            coroutine.wrap(AutoLeviathan)()
        end
    end
})

Tabs.Farming:AddToggle("AutoGearToggle", {
    Title = "Auto Engrenagem",
    Description = "Farm automático de engrenagens",
    Default = false,
    Callback = function(value)
        Settings.AutoFarm.Gear = value
        if value then
            coroutine.wrap(AutoGear)()
        end
    end
})

Tabs.Farming:AddToggle("AutoMirageToggle", {
    Title = "Auto Mirage",
    Description = "Farm automático da ilha Mirage",
    Default = false,
    Callback = function(value)
        Settings.AutoFarm.Mirage = value
        if value then
            coroutine.wrap(AutoMirage)()
        end
    end
})


-- ... (todo o código anterior permanece o mesmo até a seção de configurações)

-- Atualizando a tabela de configurações
local Settings = {
    -- ... (configurações anteriores permanecem)
    AutoFarm = {
        -- ... (outras configurações de auto farm)
        Leviathan = false,
        Gear = false,
        Mirage = false,
        V4 = false,
        V4Race = "Human" -- Pode ser: Human, Rabbit, Angel, Shark, Cyborg
    },
    -- ... (restante das configurações)
}

-- ... (código anterior permanece até as funções de auto farm)

--[[
    ========================
    FUNÇÃO AUTO V4
    ========================
--]]

local function AutoV4()
    while Settings.AutoFarm.V4 and task.wait() do
        -- Verifica se já tem V4
        local hasV4 = game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("CheckV4")
        
        if not hasV4 then
            -- Verifica a raça atual
            local currentRace = game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("GetRace")
            
            -- Se não for a raça desejada, tenta transformar
            if currentRace ~= Settings.AutoFarm.V4Race then
                -- Tenta transformar na raça desejada
                game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("TransformRace", Settings.AutoFarm.V4Race)
            else
                -- Coleta materiais para V4
                
                -- Fragmentos de Observação
                if Workspace:FindFirstChild("Observation") then
                    HumanoidRootPart.CFrame = Workspace.Observation.HumanoidRootPart.CFrame * CFrame.new(0, 0, -10)
                    game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("Attack", "Observation")
                end
                
                -- Fruta do Mistério
                for _, fruit in ipairs(Workspace:GetChildren()) do
                    if fruit.Name == "MysteryFruit" then
                        HumanoidRootPart.CFrame = fruit.Handle.CFrame
                        task.wait(0.5)
                        firetouchinterest(HumanoidRootPart, fruit.Handle, 0)
                        firetouchinterest(HumanoidRootPart, fruit.Handle, 1)
                    end
                end
                
                -- Tenta evoluir para V4
                game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("EvolveV4")
            end
        else
            -- Se já tem V4, apenas melhora as habilidades
            game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("UpgradeV4")
        end
    end
end

-- ... (código anterior permanece até a interface do usuário)

-- Atualizando a interface do usuário para incluir as novas funções
Tabs.Farming:AddToggle("AutoV4Toggle", {
    Title = "Auto V4",
    Description = "Farm automático para evoluir para V4",
    Default = false,
    Callback = function(value)
        Settings.AutoFarm.V4 = value
        if value then
            coroutine.wrap(AutoV4)()
        end
    end
})

Tabs.Farming:AddDropdown("V4RaceDropdown", {
    Title = "Raça para V4",
    Values = {"Human", "Rabbit", "Angel", "Shark", "Cyborg"},
    Default = 1,
    Callback = function(value)
        Settings.AutoFarm.V4Race = value
    end
})

-- ... (restante do código permanece o mesmo)

-- TAB: AUTO FARM (Adicionar todos os toggles de auto farm)

-- TAB: JOGADOR (Adicionar todas as funções de jogador)

-- TAB: VISUAL (Adicionar configurações de ESP)

-- TAB: TELEPORTE (Adicionar teleportes)

-- TAB: DIVERSOS (Adicionar funções diversas)

-- Inicialização
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

SaveManager:IgnoreThemeSettings()
InterfaceManager:SetFolder("BloxFruitsUltimate")
SaveManager:SetFolder("BloxFruitsUltimate/settings")

Window:SelectTab(1)

-- Iniciar serviços
ESP:Init()
AntiAFK()


Fluent:Notify({
    Title = "Script Carregado",
    Content = "Blox Fruits Ultimate foi carregado com sucesso!",
    Duration = 5
})

-- Carregar configurações salvas
SaveManager:LoadAutoloadConfig()
